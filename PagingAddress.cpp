#include <iostream>
using namespace std;

int main() {
    int pageSize, logicalAddress, numPages;
    
    cout << "Enter page size (bytes): ";
    cin >> pageSize;

    cout << "Enter number of pages: ";
    cin >> numPages;

    int pageTable[numPages];
    cout << "Enter frame number for each page:\n";
    for (int i = 0; i < numPages; i++) {
        cout << "Page " << i << ": ";
        cin >> pageTable[i];
    }

    cout << "Enter logical address: ";
    cin >> logicalAddress;

    int pageNumber = logicalAddress / pageSize;
    int offset = logicalAddress % pageSize;

    if (pageNumber >= numPages) {
        cout << "Invalid logical address! Page number out of range.\n";
        return 0;
    }

    int frameNumber = pageTable[pageNumber];
    int physicalAddress = (frameNumber * pageSize) + offset;

    cout << "Page Number: " << pageNumber << endl;
    cout << "Offset: " << offset << endl;
    cout << "Frame Number: " << frameNumber << endl;
    cout << "Physical Address: " << physicalAddress << endl;

    return 0;
}

What is Address Translation?
When a program runs, it uses logical addresses (generated by the CPU), but these need to be converted into physical addresses (actual locations in RAM). This translation is managed differently in paging and segmentation.

📦 Address Translation using Paging
Paging divides:

Logical address space into fixed-size pages

Physical memory into fixed-size frames

👉 Both are the same size to make mapping easy.

🔸 Paging Translation Process:
Logical address is divided into:

Page number (p)

Page offset (d)

The Page number (p) is used to look up the frame number (f) in the Page Table.

The Frame number (f) is combined with the offset (d) to form the Physical address.

📊 Formula:
Logical Address (LA) = (p, d)
Physical Address (PA) = (f × frame size) + d

📄 Example:
Page size = 1 KB (1024 bytes)

Logical Address = 2049
→ 2049 in binary = 2 pages (page 2) and 1-byte offset

So:

Page Number (p) = 2

Offset (d) = 1

If Page Table says:
Page 2 is in Frame 5

Then:
Physical Address = (5 × 1024) + 1 = 5120 + 1 = 5121

📌 Advantages:
No external fragmentation

Easy to implement

Disadvantages:

Internal fragmentation (last page may not be fully used)

Overhead of maintaining page tables

📏 Address Translation using Segmentation
Segmentation divides:

Logical address space into variable-sized segments based on logical divisions (functions, arrays, stack, etc.)

👉 More human-friendly since segments represent actual program parts.

🔸 Segmentation Translation Process:
Logical Address is divided into:

Segment number (s)

Offset (d)

The Segment number (s) is used to find the Base address and Limit (length) in the Segment Table.

Check if offset (d) ≤ limit:

If yes → Physical Address = Base + Offset

If no → Trap to an error (Segmentation fault)

📊 Formula:
Logical Address (LA) = (s, d)
Physical Address (PA) = base[s] + d

📄 Example:
Segment table:
| Segment | Base | Limit |
|:---------|:------|:-------|
| 0 | 1000 | 500 |
| 1 | 2000 | 800 |

Logical Address: (1, 400)
→ Segment = 1, Offset = 400
→ Base of segment 1 = 2000

Physical Address = 2000 + 400 = 2400

If offset was 900 → Error (as 900 > 800)

📌 Advantages:
No internal fragmentation

Logical division of program parts

Disadvantages:

External fragmentation possible

Complex management

📊 Final Comparison:
Feature	Paging	Segmentation
Division Type	Fixed-size pages	Variable-size segments
Fragmentation	Internal	External
Table Used	Page Table	Segment Table
Address Parts	Page number, offset	Segment number, offset
Human Logic	No	Yes (functions, arrays, etc.)

🔥 TL;DR:
Paging is like a pizza box with equal slices 🍕, while Segmentation is like a thali plate with different-sized compartments 🍛 for dal, rice, roti, etc.

Both have their pros and cons, but the CPU needs to translate addresses from logical to physical — and this is how it’s done!

